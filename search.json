[
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "new-notebook",
    "section": "",
    "text": "---\ntitle: Example Blog\nsubtitle: Publishing with Quarto and nbdev\nlisting:\n  sort: \"date desc\"\n  contents: \"posts\"\n  sort-ui: false\n  filter-ui: false\n  categories: true\n  feed: true\npage-layout: full\n---",
    "crumbs": [
      "blog"
    ]
  },
  {
    "objectID": "blog/posts/post1/index.html",
    "href": "blog/posts/post1/index.html",
    "title": "Lesson 3: HuggingFace NLP Models",
    "section": "",
    "text": "Running powerful NLP models with the HuggingFace transformers library.",
    "crumbs": [
      "blog",
      "posts",
      "post1"
    ]
  },
  {
    "objectID": "blog/posts/post1/index.html#notebook-best-practices",
    "href": "blog/posts/post1/index.html#notebook-best-practices",
    "title": "Lesson 3: HuggingFace NLP Models",
    "section": "Notebook best practices",
    "text": "Notebook best practices\nFirst, let’s set up our notebook to be fully interactive and easy to use. We can do this with a couple of “magic functions” built-in to Jupyter.\nSpecifically, we use the magic autoreload and matplotlib functions. The cell below shows them in action:\n\n# best practice notebook magic\n\nLet’s take a look at what these magic functions do.\nautoreload dynamically reloads code libraries, even as they’re changing under the hood. That means we do not have to restart the notebook after every change. We can instead code and experiment on the fly.\nmatplotlib inline automatically displays any plots below the code cell that created them. The plots are also saved in the notebook itself, which is perfect for our blog posts.\nAll of our notebooks going forward will start with these magic functions.\nLet’s start with the \"hello, world!\" of NLP: sentiment analysis.",
    "crumbs": [
      "blog",
      "posts",
      "post1"
    ]
  },
  {
    "objectID": "blog/posts/post1/index.html#first-a-pipeline",
    "href": "blog/posts/post1/index.html#first-a-pipeline",
    "title": "Lesson 3: HuggingFace NLP Models",
    "section": "First, a Pipeline",
    "text": "First, a Pipeline\nLet’s take a look at the HuggingFace NLP model that we’ll run. At a high level, the model is built around three key pieces:\n\nA Config file.\n\nA Preprocessor file.\n\nModel file(s).\n\nThe HuggingFace API has a handy, high-level pipeline that wraps up all three objects for us.\n\n\n\n\n\n\nImportant\n\n\n\nBefore going forward, make sure that the llm-env environment from the first lesson is active. This environment has the HuggingFace libraries used below.\n\n\nThe code below uses the transformers library to build a Sentiment Analysis pipeline.\n\n# load in the pipeline object from HuggingFace\nfrom transformers import pipeline\n\n# create a sentiment analysis pipeline\nclassifier = pipeline(\"sentiment-analysis\", model=\"nlptown/bert-base-multilingual-uncased-sentiment\")\n\n                                                                                                                                                                                                                    Since we didn't specify a model, you can see in the output above that HuggingFace picked a [distilbert model](distilbert-base-uncased-finetuned-sst-2-english) for us by default.  \nWe will learn more about what exactly distilbert is and how it works later on. For now, think of it as a useful NLP genie who can look at a sentence and tell us whether its has a positive or negative tone.\nNext, let’s find out what the model thinks about the sentence: \"HuggingFace pipelines are awesome!\"\n\n# sentiment analysis on a simple, example sentence\nexample_sentence = \"Si, Me Gusta AI!\"\nclassifier(example_sentence)\n\n[{'label': '5 stars', 'score': 0.4380775988101959}]\n\n\nNot bad. We see a strong confident score for a POSITIVE label, as could be expected.\nWe can also pass many sentences at once, which starts to show the bulk processing power of these models. Let’s process four sentences at once: three positive ones, and a clearly negative one.\n\n# many sentences at once, in a python list\nmany_sentences = [\n    \"A chicken is a chicken.\",\n    \"Everybody knows that!\",\n    \"A rose is a rose is a rose.\",\n    \"I really like this course so far\",\n]\n\n# process many sentences at once\n\nresults = classifier(many_sentences)\n\n# check the tone of each sentence\nfor result in results:\n    print(f\"label: {result['label']}, with score: {round(result['score'], 4)}\")\n\nlabel: 1 star, with score: 0.2874\nlabel: 5 stars, with score: 0.626\nlabel: 5 stars, with score: 0.33\nlabel: 5 stars, with score: 0.6003\n\n\nCongrats! You’ve now ran a HuggingFace pipeline and used it to analyze the tone of a few sentences. Next, let’s take a closer look at the pipeline object.",
    "crumbs": [
      "blog",
      "posts",
      "post1"
    ]
  },
  {
    "objectID": "blog/posts/post1/index.html#config-class",
    "href": "blog/posts/post1/index.html#config-class",
    "title": "Lesson 3: HuggingFace NLP Models",
    "section": "Config class",
    "text": "Config class\nThe config class is a simple map with the options and configurations of a model. It has the key-value pairs that define a model’s architecture and hyperparameters.\n\n# config for the model\nfrom transformers import DistilBertConfig",
    "crumbs": [
      "blog",
      "posts",
      "post1"
    ]
  },
  {
    "objectID": "blog/posts/post1/index.html#preprocessor-class",
    "href": "blog/posts/post1/index.html#preprocessor-class",
    "title": "Lesson 3: HuggingFace NLP Models",
    "section": "Preprocessor class",
    "text": "Preprocessor class\nThe preprocessor object in this case is a Tokenizer. Tokenizers convert strings and characters into special tensor inputs for the LLM.\n\n\n\n\n\n\nNote\n\n\n\nCorrectly pre-processing inputs is one of the most important and error-prone steps in using ML models. In other words, it’s good to offload to a class that’s already been tested and debugged.\n\n\n\n# input preprocessor to tokenize strings\nfrom transformers import DistilBertTokenizer\n\nThe model class holds the weights and parameters for the actual LLM. It’s the “meat and bones” of the setup, so to speak.\n\n# the text classifier model\nfrom transformers import DistilBertForSequenceClassification",
    "crumbs": [
      "blog",
      "posts",
      "post1"
    ]
  },
  {
    "objectID": "blog/posts/post1/index.html#naming-the-model",
    "href": "blog/posts/post1/index.html#naming-the-model",
    "title": "Lesson 3: HuggingFace NLP Models",
    "section": "Naming the model",
    "text": "Naming the model\nWe need to know a model’s full, proper name in to load it from HuggingFace. Its name is how we find the model on the HuggingFace Model Hub.\nOnce we know its full name, there is a handy from_pretrained() function that will automatically find and download the pieces for us.\nIn this case, the distilbert model’s full name is:\n&gt; distilbert-base-uncased-finetuned-sst-2-english.\n\n# sentiment analysis model name\nmodel_name = 't5-base'\n\nIn the code below we can now load each of the three NLP pieces for this model.\n\n# create the config\nconfig = DistilBertConfig.from_pretrained(model_name)\n\n# create the input tokenizer \ntokenizer = DistilBertTokenizer.from_pretrained(model_name)\n\n# create the model\nmodel = DistilBertForSequenceClassification.from_pretrained(model_name)\n\nNext we will compose these three pieces together to mimic the original pipeline example.",
    "crumbs": [
      "blog",
      "posts",
      "post1"
    ]
  },
  {
    "objectID": "blog/posts/post1/index.html#putting-together-a-simple_pipeline",
    "href": "blog/posts/post1/index.html#putting-together-a-simple_pipeline",
    "title": "Lesson 3: HuggingFace NLP Models",
    "section": "Putting together a simple_pipeline",
    "text": "Putting together a simple_pipeline\n\nPreprocessing the inputs\nFirst, we create a preprocess function to turn a given text string into the proper, tokenized inputs than an LLM expects.\n\ndef preprocess(text: str):\n    \"\"\"\n    Sends `text` through the model's tokenizer.  \n    The tokenizer turns words and characters into proper inputs for an NLP model.\n    \"\"\"\n    tokenized_inputs = tokenizer(text, return_tensors='pt')\n    return tokenized_inputs\n\nLet’s test this preprocessing function on the example sentence from earlier.\n\n# manually preprocessing the example sentence: \"HuggingFace pipelines are awesome!\"\npreprocess(example_sentence)\n\n{'input_ids': tensor([[ 101, 4205, 2018, 1037, 2307, 2154,  999,  102]]), 'attention_mask': tensor([[1, 1, 1, 1, 1, 1, 1, 1]])}\n\n\nIt turned an input string into numerical embeddings for the LLM. We’ll breakdown what exactly this output means later on in the course. For now, think of it as sanitizing and formatting the text into a format that the LLM has been trained to work with.\n\n\nRunning the model\nNext up, let’s make our own forward function that run the LLM on preprocessed inputs.\n\ndef forward(text: str):\n    \"\"\"\n    First we preprocess the `text` into tokens.\n    Then we send the `tokenized_inputs` to the model.\n    \"\"\"\n    tokenized_inputs = preprocess(text)\n    outputs = model(**tokenized_inputs)\n    return outputs\n\n\ntokenizer?\n\nSignature:     \ntokenizer(\n    text: Union[str, List[str], List[List[str]]] = None,\n    text_pair: Union[str, List[str], List[List[str]], NoneType] = None,\n    text_target: Union[str, List[str], List[List[str]]] = None,\n    text_pair_target: Union[str, List[str], List[List[str]], NoneType] = None,\n    add_special_tokens: bool = True,\n    padding: Union[bool, str, transformers.utils.generic.PaddingStrategy] = False,\n    truncation: Union[bool, str, transformers.tokenization_utils_base.TruncationStrategy] = None,\n    max_length: Optional[int] = None,\n    stride: int = 0,\n    is_split_into_words: bool = False,\n    pad_to_multiple_of: Optional[int] = None,\n    return_tensors: Union[str, transformers.utils.generic.TensorType, NoneType] = None,\n    return_token_type_ids: Optional[bool] = None,\n    return_attention_mask: Optional[bool] = None,\n    return_overflowing_tokens: bool = False,\n    return_special_tokens_mask: bool = False,\n    return_offsets_mapping: bool = False,\n    return_length: bool = False,\n    verbose: bool = True,\n    **kwargs,\n) -&gt; transformers.tokenization_utils_base.BatchEncoding\nType:           DistilBertTokenizerFast\nString form:   \nDistilBertTokenizerFast(name_or_path='distilbert-base-uncased-finetuned-sst-2-english', vocab_siz &lt;...&gt; Token(\"[MASK]\", rstrip=False, lstrip=False, single_word=False, normalized=False, special=True),\n           }\nLength:         30522\nFile:           ~/mambaforge/envs/llm-env/lib/python3.11/site-packages/transformers/models/distilbert/tokenization_distilbert_fast.py\nDocstring:     \nConstruct a \"fast\" DistilBERT tokenizer (backed by HuggingFace's *tokenizers* library). Based on WordPiece.\n\nThis tokenizer inherits from [`PreTrainedTokenizerFast`] which contains most of the main methods. Users should\nrefer to this superclass for more information regarding those methods.\n\nArgs:\n    vocab_file (`str`):\n        File containing the vocabulary.\n    do_lower_case (`bool`, *optional*, defaults to `True`):\n        Whether or not to lowercase the input when tokenizing.\n    unk_token (`str`, *optional*, defaults to `\"[UNK]\"`):\n        The unknown token. A token that is not in the vocabulary cannot be converted to an ID and is set to be this\n        token instead.\n    sep_token (`str`, *optional*, defaults to `\"[SEP]\"`):\n        The separator token, which is used when building a sequence from multiple sequences, e.g. two sequences for\n        sequence classification or for a text and a question for question answering. It is also used as the last\n        token of a sequence built with special tokens.\n    pad_token (`str`, *optional*, defaults to `\"[PAD]\"`):\n        The token used for padding, for example when batching sequences of different lengths.\n    cls_token (`str`, *optional*, defaults to `\"[CLS]\"`):\n        The classifier token which is used when doing sequence classification (classification of the whole sequence\n        instead of per-token classification). It is the first token of the sequence when built with special tokens.\n    mask_token (`str`, *optional*, defaults to `\"[MASK]\"`):\n        The token used for masking values. This is the token used when training this model with masked language\n        modeling. This is the token which the model will try to predict.\n    clean_text (`bool`, *optional*, defaults to `True`):\n        Whether or not to clean the text before tokenization by removing any control characters and replacing all\n        whitespaces by the classic one.\n    tokenize_chinese_chars (`bool`, *optional*, defaults to `True`):\n        Whether or not to tokenize Chinese characters. This should likely be deactivated for Japanese (see [this\n        issue](https://github.com/huggingface/transformers/issues/328)).\n    strip_accents (`bool`, *optional*):\n        Whether or not to strip all accents. If this option is not specified, then it will be determined by the\n        value for `lowercase` (as in the original BERT).\n    wordpieces_prefix (`str`, *optional*, defaults to `\"##\"`):\n        The prefix for subwords.\nCall docstring:\nMain method to tokenize and prepare for the model one or several sequence(s) or one or several pair(s) of\nsequences.\n\nArgs:\n    text (`str`, `List[str]`, `List[List[str]]`, *optional*):\n        The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n        (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n        `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n    text_pair (`str`, `List[str]`, `List[List[str]]`, *optional*):\n        The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n        (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n        `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n    text_target (`str`, `List[str]`, `List[List[str]]`, *optional*):\n        The sequence or batch of sequences to be encoded as target texts. Each sequence can be a string or a\n        list of strings (pretokenized string). If the sequences are provided as list of strings (pretokenized),\n        you must set `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n    text_pair_target (`str`, `List[str]`, `List[List[str]]`, *optional*):\n        The sequence or batch of sequences to be encoded as target texts. Each sequence can be a string or a\n        list of strings (pretokenized string). If the sequences are provided as list of strings (pretokenized),\n        you must set `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n\n    add_special_tokens (`bool`, *optional*, defaults to `True`):\n        Whether or not to add special tokens when encoding the sequences. This will use the underlying\n        `PretrainedTokenizerBase.build_inputs_with_special_tokens` function, which defines which tokens are\n        automatically added to the input ids. This is usefull if you want to add `bos` or `eos` tokens\n        automatically.\n    padding (`bool`, `str` or [`~utils.PaddingStrategy`], *optional*, defaults to `False`):\n        Activates and controls padding. Accepts the following values:\n\n        - `True` or `'longest'`: Pad to the longest sequence in the batch (or no padding if only a single\n          sequence if provided).\n        - `'max_length'`: Pad to a maximum length specified with the argument `max_length` or to the maximum\n          acceptable input length for the model if that argument is not provided.\n        - `False` or `'do_not_pad'` (default): No padding (i.e., can output a batch with sequences of different\n          lengths).\n    truncation (`bool`, `str` or [`~tokenization_utils_base.TruncationStrategy`], *optional*, defaults to `False`):\n        Activates and controls truncation. Accepts the following values:\n\n        - `True` or `'longest_first'`: Truncate to a maximum length specified with the argument `max_length` or\n          to the maximum acceptable input length for the model if that argument is not provided. This will\n          truncate token by token, removing a token from the longest sequence in the pair if a pair of\n          sequences (or a batch of pairs) is provided.\n        - `'only_first'`: Truncate to a maximum length specified with the argument `max_length` or to the\n          maximum acceptable input length for the model if that argument is not provided. This will only\n          truncate the first sequence of a pair if a pair of sequences (or a batch of pairs) is provided.\n        - `'only_second'`: Truncate to a maximum length specified with the argument `max_length` or to the\n          maximum acceptable input length for the model if that argument is not provided. This will only\n          truncate the second sequence of a pair if a pair of sequences (or a batch of pairs) is provided.\n        - `False` or `'do_not_truncate'` (default): No truncation (i.e., can output batch with sequence lengths\n          greater than the model maximum admissible input size).\n    max_length (`int`, *optional*):\n        Controls the maximum length to use by one of the truncation/padding parameters.\n\n        If left unset or set to `None`, this will use the predefined model maximum length if a maximum length\n        is required by one of the truncation/padding parameters. If the model has no specific maximum input\n        length (like XLNet) truncation/padding to a maximum length will be deactivated.\n    stride (`int`, *optional*, defaults to 0):\n        If set to a number along with `max_length`, the overflowing tokens returned when\n        `return_overflowing_tokens=True` will contain some tokens from the end of the truncated sequence\n        returned to provide some overlap between truncated and overflowing sequences. The value of this\n        argument defines the number of overlapping tokens.\n    is_split_into_words (`bool`, *optional*, defaults to `False`):\n        Whether or not the input is already pre-tokenized (e.g., split into words). If set to `True`, the\n        tokenizer assumes the input is already split into words (for instance, by splitting it on whitespace)\n        which it will tokenize. This is useful for NER or token classification.\n    pad_to_multiple_of (`int`, *optional*):\n        If set will pad the sequence to a multiple of the provided value. Requires `padding` to be activated.\n        This is especially useful to enable the use of Tensor Cores on NVIDIA hardware with compute capability\n        `&gt;= 7.5` (Volta).\n    return_tensors (`str` or [`~utils.TensorType`], *optional*):\n        If set, will return tensors instead of list of python integers. Acceptable values are:\n\n        - `'tf'`: Return TensorFlow `tf.constant` objects.\n        - `'pt'`: Return PyTorch `torch.Tensor` objects.\n        - `'np'`: Return Numpy `np.ndarray` objects.\n\n    return_token_type_ids (`bool`, *optional*):\n        Whether to return token type IDs. If left to the default, will return the token type IDs according to\n        the specific tokenizer's default, defined by the `return_outputs` attribute.\n\n        [What are token type IDs?](../glossary#token-type-ids)\n    return_attention_mask (`bool`, *optional*):\n        Whether to return the attention mask. If left to the default, will return the attention mask according\n        to the specific tokenizer's default, defined by the `return_outputs` attribute.\n\n        [What are attention masks?](../glossary#attention-mask)\n    return_overflowing_tokens (`bool`, *optional*, defaults to `False`):\n        Whether or not to return overflowing token sequences. If a pair of sequences of input ids (or a batch\n        of pairs) is provided with `truncation_strategy = longest_first` or `True`, an error is raised instead\n        of returning overflowing tokens.\n    return_special_tokens_mask (`bool`, *optional*, defaults to `False`):\n        Whether or not to return special tokens mask information.\n    return_offsets_mapping (`bool`, *optional*, defaults to `False`):\n        Whether or not to return `(char_start, char_end)` for each token.\n\n        This is only available on fast tokenizers inheriting from [`PreTrainedTokenizerFast`], if using\n        Python's tokenizer, this method will raise `NotImplementedError`.\n    return_length  (`bool`, *optional*, defaults to `False`):\n        Whether or not to return the lengths of the encoded inputs.\n    verbose (`bool`, *optional*, defaults to `True`):\n        Whether or not to print more information and warnings.\n    **kwargs: passed to the `self.tokenize()` method\n\nReturn:\n    [`BatchEncoding`]: A [`BatchEncoding`] with the following fields:\n\n    - **input_ids** -- List of token ids to be fed to a model.\n\n      [What are input IDs?](../glossary#input-ids)\n\n    - **token_type_ids** -- List of token type ids to be fed to a model (when `return_token_type_ids=True` or\n      if *\"token_type_ids\"* is in `self.model_input_names`).\n\n      [What are token type IDs?](../glossary#token-type-ids)\n\n    - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n      `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names`).\n\n      [What are attention masks?](../glossary#attention-mask)\n\n    - **overflowing_tokens** -- List of overflowing tokens sequences (when a `max_length` is specified and\n      `return_overflowing_tokens=True`).\n    - **num_truncated_tokens** -- Number of tokens truncated (when a `max_length` is specified and\n      `return_overflowing_tokens=True`).\n    - **special_tokens_mask** -- List of 0s and 1s, with 1 specifying added special tokens and 0 specifying\n      regular sequence tokens (when `add_special_tokens=True` and `return_special_tokens_mask=True`).\n    - **length** -- The length of the inputs (when `return_length=True`)\n\n\nLet’s check what this outputs for our running example sentence.\n\noutputs = forward(example_sentence); outputs\n\nSequenceClassifierOutput(loss=None, logits=tensor([[-4.2644,  4.6256]], grad_fn=&lt;AddmmBackward0&gt;), hidden_states=None, attentions=None)\n\n\nYou’ll see a lot going on in the SequenceClassifierOutput above. To be honest, this is where the original pipeline does most of the heavy-lifting for us. It takes the raw, detailed output from an LLM and converts it into a more human-readable format.\nWe’ll mimic this heavy-lifting by using the Config class and model outputs to find out whether the sentence is positive or negative.\n\ndef process_outputs(outs):\n    \"\"\"\n    Converting the raw model outputs into a human-readable result.\n\n    Steps:\n        1. Grab the raw \"scores\" from the model for Positive and Negative labels.  \n        2. Find out which score is the highest (aka the model's decision).  \n        3. Use the `config` object to find the class label for the highest score.  \n        4. Turn the raw score into a human-readable probability value.  \n        5. Print out the predicted labels with its probability.  \n    \"\"\"\n    # 1. Grab the raw \"scores\" that from the model for Positive and Negative labels\n    logits = outs.logits\n\n    # 2. Find the strongest label score, aka the model's decision\n    pred_idx = logits.argmax(1).item()\n\n    # 3. Use the `config` object to find the class label\n    pred_label = config.id2label[pred_idx]  \n\n    # 4. Calculate the human-readable number for the score\n    pred_score = logits.softmax(-1)[:, pred_idx].item()\n\n    # 5. return the label and score in a dictionary\n    return {\n        'label': pred_label,\n        'score': pred_score, \n    }\n\nWe can now put together a simple_pipeline, and check how it compares to the original pipeline.\n\ndef simple_pipeline(text):\n    \"\"\"\n    Putting the NLP pieces and functions together into a pipeline.\n    \"\"\"\n    # get the model's raw output\n    model_outs = forward(text)\n    # convert the raw outputs into a human readable result\n    predictions = process_outputs(model_outs)\n    return predictions\n\nCalling the simple_pipeline on the example sentence, drumroll please…\n\n# running out simple pipeline on the example text\nsimple_pipeline(\"HIIII\")\n\n{'label': 'POSITIVE', 'score': 0.9883008599281311}\n\n\nAnd just like that, we too a small peek under the pipeline hood and built our own, simple working version.\nOne pain point: we had to know the full, proper name of the different Distilbert* pieces to import the Config, Preprocessor, and Model. This gets overwhelming fast given the flood of LLM models released almost daily. Thankfully, HuggingFace has come up with a great solution to this problem: the Auto class.",
    "crumbs": [
      "blog",
      "posts",
      "post1"
    ]
  },
  {
    "objectID": "blog/posts/post1/index.html#using-the-custom-sentimentpipeline",
    "href": "blog/posts/post1/index.html#using-the-custom-sentimentpipeline",
    "title": "Lesson 3: HuggingFace NLP Models",
    "section": "Using the custom SentimentPipeline",
    "text": "Using the custom SentimentPipeline\nLet’s leverage both the new class and a different model, to show the power of Auto classes.\nFor fun, let’s use BERT model that was trained specifically on tweets. The full model’s name is finiteautomata/bertweet-base-sentiment-analysis.\n\n# using a different model\nnew_model_name = 'finiteautomata/bert-base-spanish-wwm-uncased-reranker-25'\n\n\nnew_model_name??\n\nType:        str\nString form: finiteautomata/bert-base-spanish-wwm-uncased-reranker-25\nLength:      56\nDocstring:  \nstr(object='') -&gt; str\nstr(bytes_or_buffer[, encoding[, errors]]) -&gt; str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.\n\n\nNow let’s run it on our handy example sentence.\n\nexample_sentence2 = \"Te odio!\"\n\n\n# calling our new, flexible pipeline\nsimple_pipeline(example_sentence2)\n\n{'label': 'LABEL_1', 'score': 0.5055498480796814}\n\n\n\nsimple_pipeline.model\n\nRobertaForSequenceClassification(\n  (roberta): RobertaModel(\n    (embeddings): RobertaEmbeddings(\n      (word_embeddings): Embedding(64001, 768, padding_idx=1)\n      (position_embeddings): Embedding(130, 768, padding_idx=1)\n      (token_type_embeddings): Embedding(1, 768)\n      (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)\n      (dropout): Dropout(p=0.1, inplace=False)\n    )\n    (encoder): RobertaEncoder(\n      (layer): ModuleList(\n        (0-11): 12 x RobertaLayer(\n          (attention): RobertaAttention(\n            (self): RobertaSelfAttention(\n              (query): Linear(in_features=768, out_features=768, bias=True)\n              (key): Linear(in_features=768, out_features=768, bias=True)\n              (value): Linear(in_features=768, out_features=768, bias=True)\n              (dropout): Dropout(p=0.1, inplace=False)\n            )\n            (output): RobertaSelfOutput(\n              (dense): Linear(in_features=768, out_features=768, bias=True)\n              (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)\n              (dropout): Dropout(p=0.1, inplace=False)\n            )\n          )\n          (intermediate): RobertaIntermediate(\n            (dense): Linear(in_features=768, out_features=3072, bias=True)\n            (intermediate_act_fn): GELUActivation()\n          )\n          (output): RobertaOutput(\n            (dense): Linear(in_features=3072, out_features=768, bias=True)\n            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)\n            (dropout): Dropout(p=0.1, inplace=False)\n          )\n        )\n      )\n    )\n  )\n  (classifier): RobertaClassificationHead(\n    (dense): Linear(in_features=768, out_features=768, bias=True)\n    (dropout): Dropout(p=0.1, inplace=False)\n    (out_proj): Linear(in_features=768, out_features=3, bias=True)\n  )\n)\n\n\nCongrats! You’ve now built a flexible pipeline for Sentiment Analysis that can leverage most NLP models on the HuggingFace hub.\n\nfrom transformers import AutoTokenizer, AutoModelForSeq2SeqLM\n\nclass TextSummarizationPipeline:\n    def __init__(self, model_name: str):\n        \"\"\"\n        Simple Text Summarization pipeline.\n        \"\"\"\n        self.model_name = model_name\n        self.config = AutoConfig.from_pretrained(self.model_name)\n        self.tokenizer = AutoTokenizer.from_pretrained(self.model_name)\n        self.model = AutoModelForSeq2SeqLM.from_pretrained(self.model_name)\n\n    def preprocess(self, text: str):\n        \"\"\"\n        Preprocesses text for summarization.\n        \"\"\"\n        inputs = self.tokenizer(text, return_tensors=\"pt\", truncation=True, max_length=512)\n        # Add an \"end of summary\" token if necessary for your model\n        inputs['input_ids'] = self.add_end_of_summary_token(inputs['input_ids'])\n        return inputs\n\n    def add_end_of_summary_token(self, input_ids):\n        \"\"\"\n        Adds the end of summary token to the input sequence.\n        \"\"\"\n        # Modify this based on your model's specific end of summary token ID\n        eos_token_id = self.tokenizer.eos_token_id\n        input_ids = torch.cat((input_ids, torch.tensor([eos_token_id]).unsqueeze(0)), dim=-1)\n        return input_ids\n\n    def forward(self, preprocessed_text):\n        \"\"\"\n        Passes preprocessed text through the summarization model.\n        \"\"\"\n        # Include preprocessed_text['input_ids'] as decoder_input_ids\n        outputs = self.model(**preprocessed_text, decoder_input_ids=preprocessed_text['input_ids'])\n        return outputs\n\n    def process_outputs(self, model_outputs):\n        \"\"\"\n        Extracts the generated summary text.\n        \"\"\"\n        summary_ids = model_outputs.logits.argmax(-1)  # Get most likely token IDs\n        summary = self.tokenizer.decode(summary_ids[0], skip_special_tokens=True)  # Decode and remove special tokens\n        return summary\n\n    def __call__(self, text: str):\n        \"\"\"\n        Summarizes the provided text.\n        \"\"\"\n        preprocessed_text = self.preprocess(text)\n        model_outputs = self.forward(preprocessed_text)\n        summary = self.process_outputs(model_outputs)\n        return summary\n\n\n# Example usage\nsummarizer = TextSummarizationPipeline(\"t5-base\")\ntext = \"The first 4 points1 maximize the beauty - fully channel the beauty with in. Maybe ask what makes this moment beautiful? See if beauty can be increased in every situation. MtB also could be taken as A use of reason and also a disciplining of the senses to focus on beauty (i.e. all the pretty flowers, all the pretty birds).2 full expression - it takes a lot of effort for one to understand who they are when they are comfortable and how to channel the most real expressions of themselves What holds people back? Shyness, distraction (inability to focus on that which they want express)3 expect rising - this means our expectations are constantly rising. Kinda in line with give em an inch they'll take a mile also related to law of diminishing returns -The law of diminishing returns states that in all productive processes, adding more of one factor of production, while holding all others constant (ceteris paribus), will at some point yield lower incremental per-unit returns. Tooo much ice cream too much cash4 power of pettiness - is the idea that pettiness is the destroyer of all people. That even the best of us can’t truly be unaffected by the petty bullshit around us. They can however minimize its effects. In my own life I am obliterated by friends and coworker’s snide remarks and judgments. How do I minimize its effects? By talking myself down, deep breaths, weed, alchohol, revenge...\"\nsummary = summarizer(text)\nprint(summary)\n\nNameError: name 'torch' is not defined\n\n\n\nmodel_name\n\nNameError: name 'model_name' is not defined\n\n\n\nfrom transformers import pipeline\n\nsummarizer = pipeline(\"summarization\", model=\"t5-base\")\n\n# Example usage\ntext = \" maximize the beauty - fully channel the beauty with in. Maybe ask what makes this moment beautiful? See if beauty can be increased in every situation. MtB also could be taken as A use of reason and also a disciplining of the senses to focus on beauty (i.e. all the pretty flowers, all the pretty birds)\"\n\nsummary = summarizer(text, max_length=30)\n\nprint(summary)\n\n[{'summary_text': 'maximize the beauty - fully channel the beauty with in . also could be taken as a use of reason and also a disciplining'}]",
    "crumbs": [
      "blog",
      "posts",
      "post1"
    ]
  },
  {
    "objectID": "blog/posts/post1/index.html#asking-questions-and",
    "href": "blog/posts/post1/index.html#asking-questions-and",
    "title": "Lesson 3: HuggingFace NLP Models",
    "section": "Asking questions: ? and ??",
    "text": "Asking questions: ? and ??\nLastly, we can literally interrogate an object in Jupyter for more information.\nIf we tag a single ? after an object, we’ll get its basic documentation (docstring). Note that we omit it here to keep the notebook from getting too busy.\n\n## the power of asking questions\nclassifier?\n\nIf we tag on two question marks: ??, then we get the full source code of the object:\n\n## really curious about classifier\nclassifier??\n\nBoth ? and ?? are excellent and quick ways to look under the hood of any object in Jupyter.",
    "crumbs": [
      "blog",
      "posts",
      "post1"
    ]
  },
  {
    "objectID": "blog/posts/post1/index.html#inspecting-a-specific-classifier-function",
    "href": "blog/posts/post1/index.html#inspecting-a-specific-classifier-function",
    "title": "Lesson 3: HuggingFace NLP Models",
    "section": "Inspecting a specific classifier function",
    "text": "Inspecting a specific classifier function\nLet’s take a look at the function that does the heavy lifting for our sentiment analysis task: forward().\n\n# looking at what actually runs the inputs\nclassifier.forward\n\n&lt;bound method Pipeline.forward of &lt;transformers.pipelines.text_classification.TextClassificationPipeline object at 0x11cd918d0&gt;&gt;\n\n\nWhat does this function actually do? Let’s find out.\n\n# source code of the forward function\nclassifier.forward??\n\nSignature: classifier.forward(model_inputs, **forward_params)\nDocstring: &lt;no docstring&gt;\nSource:   \n    def forward(self, model_inputs, **forward_params):\n        with self.device_placement():\n            if self.framework == \"tf\":\n                model_inputs[\"training\"] = False\n                model_outputs = self._forward(model_inputs, **forward_params)\n            elif self.framework == \"pt\":\n                inference_context = self.get_inference_context()\n                with inference_context():\n                    model_inputs = self._ensure_tensor_on_device(model_inputs, device=self.device)\n                    model_outputs = self._forward(model_inputs, **forward_params)\n                    model_outputs = self._ensure_tensor_on_device(model_outputs, device=torch.device(\"cpu\"))\n            else:\n                raise ValueError(f\"Framework {self.framework} is not supported\")\n        return model_outputs\nFile:      ~/mambaforge/envs/llm-env/lib/python3.11/site-packages/transformers/pipelines/base.py\nType:      method\n\n\nWe can see that it automatically handles whether we’re running a TensorFlow (tf) or PyTorch (pt) model. Then, it makes sure the tensors are on the correct device. Lastly is calls another function, _forward() on the prepared inputs.\nWe can follow the rabbit hole as far down as needed. Let’s take a look at the source of _forward.\n\n# going deeper\nclassifier._forward??\n\nSignature: classifier._forward(model_inputs)\nDocstring:\n_forward will receive the prepared dictionary from `preprocess` and run it on the model. This method might\ninvolve the GPU or the CPU and should be agnostic to it. Isolating this function is the reason for `preprocess`\nand `postprocess` to exist, so that the hot path, this method generally can run as fast as possible.\n\nIt is not meant to be called directly, `forward` is preferred. It is basically the same but contains additional\ncode surrounding `_forward` making sure tensors and models are on the same device, disabling the training part\nof the code (leading to faster inference).\nSource:   \n    def _forward(self, model_inputs):\n        # `XXXForSequenceClassification` models should not use `use_cache=True` even if it's supported\n        model_forward = self.model.forward if self.framework == \"pt\" else self.model.call\n        if \"use_cache\" in inspect.signature(model_forward).parameters.keys():\n            model_inputs[\"use_cache\"] = False\n        return self.model(**model_inputs)\nFile:      ~/mambaforge/envs/llm-env/lib/python3.11/site-packages/transformers/pipelines/text_classification.py\nType:      method\n\n\nAh, we can see it calls the model of the classifier. This is the distilbert model we saw earlier! Now we can peek under the hood at the actual Transformer LLM.\n\n# the distilbert sentiment analysis model\nclassifier.model\n\nBertForSequenceClassification(\n  (bert): BertModel(\n    (embeddings): BertEmbeddings(\n      (word_embeddings): Embedding(105879, 768, padding_idx=0)\n      (position_embeddings): Embedding(512, 768)\n      (token_type_embeddings): Embedding(2, 768)\n      (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True)\n      (dropout): Dropout(p=0.1, inplace=False)\n    )\n    (encoder): BertEncoder(\n      (layer): ModuleList(\n        (0-11): 12 x BertLayer(\n          (attention): BertAttention(\n            (self): BertSelfAttention(\n              (query): Linear(in_features=768, out_features=768, bias=True)\n              (key): Linear(in_features=768, out_features=768, bias=True)\n              (value): Linear(in_features=768, out_features=768, bias=True)\n              (dropout): Dropout(p=0.1, inplace=False)\n            )\n            (output): BertSelfOutput(\n              (dense): Linear(in_features=768, out_features=768, bias=True)\n              (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True)\n              (dropout): Dropout(p=0.1, inplace=False)\n            )\n          )\n          (intermediate): BertIntermediate(\n            (dense): Linear(in_features=768, out_features=3072, bias=True)\n            (intermediate_act_fn): GELUActivation()\n          )\n          (output): BertOutput(\n            (dense): Linear(in_features=3072, out_features=768, bias=True)\n            (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True)\n            (dropout): Dropout(p=0.1, inplace=False)\n          )\n        )\n      )\n    )\n    (pooler): BertPooler(\n      (dense): Linear(in_features=768, out_features=768, bias=True)\n      (activation): Tanh()\n    )\n  )\n  (dropout): Dropout(p=0.1, inplace=False)\n  (classifier): Linear(in_features=768, out_features=5, bias=True)\n)\n\n\nWe will breakdown the different pieces in this model later on in the course.\nThe important takeaway for now is that this shows the main structure of most Transformer LLM models. The changes are mostly incremental from this foundation.",
    "crumbs": [
      "blog",
      "posts",
      "post1"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "source\n\nfoo\n\n foo ()",
    "crumbs": [
      "core"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "new-notebook",
    "section": "",
    "text": "---\ntitle: Example Blog\nsubtitle: Publishing with Quarto and nbdev\nlisting:\n  sort: \"date desc\"\n  contents: \"blog/posts\"\n  sort-ui: false\n  filter-ui: false\n  categories: true\n  feed: true\npage-layout: full\n---",
    "crumbs": [
      "```yaml"
    ]
  }
]